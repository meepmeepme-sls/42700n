#pragma config(Motor,  motor1,          BL,            tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor2,          BR,            tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          FR,            tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor4,          FL,            tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Cody's ROBOTC X Holonomic Code
// =======================
// Usage:	Drive code for "X" Holonomic drive
// License:	Public Domain, use at your own risk.
//
//  ROBOT SEEN FROM ABOVE
//
//        X FRONT X
//      X           X
//    X  P1       P2  X
//            X
//           XXX
//            X
//    X  P4       P3  X
//      X           X
//        X       X

// Controller 1/2, Stick L/R, Axis X/Y
#define C1LX vexRT[ChB]
#define C1LY vexRT[ChA]
#define C1RX vexRT[ChC]

task main() {

	while(true) {

		// Y component, X component, Rotation
		motor[FL] = C1LY + C1LX + C1RX;
		motor[FR] =  -C1LY + C1LX + C1RX;
		motor[BR] =  -C1LY - C1LX + C1RX;
		motor[BL] = C1LY - C1LX + C1RX;

		// Motor values can only be updated every 20ms
		wait10Msec(2);

	}

}

// Cody's ROBOTC + Holonomic Code
// =======================
// Usage:	Drive code for "+" Holonomic drive
// License:	Public Domain, use at your own risk.

/*Controller 1/2, Stick L/R, Axis X/Y
#define C1LX vexRT[Ch4]
#define C1LY vexRT[Ch3]
#define C1RX vexRT[Ch1]

task main() {

	while(true) {

		// Y component, X component, Rotation
		motor[FR] = -C1LX - C1RX;
		motor[LE] = -C1LY - C1RX;
		motor[RI] =  C1LY - C1RX;
		motor[BK] =  C1LX - C1RX;

		// Motor values can only be updated every 20ms
		wait10Msec(2);

	}
*/
